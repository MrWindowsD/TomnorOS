# TomnorOS — Продвинутая оптимизация Windows 10/11
Продвинутая оптимизация ОС Windows 10/11
В данном проекте мы поговорим про оптимизацию Windows 11 в целом, в том числе о продвинутом способе оптимизации, который был собран от многих энтузиастов и проверенный мною. Я не буду относить эти методы к оптимизации ранних версий, в том числе 10, хоть некоторые методы и применимы к ним, тем не менее алгоритм оптимизации может сильно отличаться.

Также вот архив для установки всех необходимых компонентов, которые будут использовать в данном проекте и дополняться в будущем: ***

_Данный проект предназначен для опытных пользователей_.

---
Поговорим немного в целом про оптимизацию, и что она под собой подразумевает с моей точки зрения.

![Факт-карта_ПК_Богов](https://github.com/user-attachments/assets/84a59e4a-bcd9-4dc2-a8dd-89cfd2238b04)
Немного зайдём из далека. Мой опыт работы с железом, ОС, программами и драйверами вот уже как 10 лет, если не больше. За это время я пробовал много чего и много в чём экспериментировал, что-то работало, что-то работало не как нужно, не мало раз ломал Windows, много узнал о её работе, и работе разных программ. Тут будет весь самый сок из всего этого многолетнего опыта. Но это не точно

И многие могут сказать, что для мощного ПК не нужна оптимизация, с чем я не согласен. Всё потому что оптимизация несёт широкий характер, а не только облегчение ОС для быстрой работы.

Я подразумеваю оптимизацию как: "Настройка ОС под себя", другими словами мы настраиваем ОС под свои нужны и задачи: игры, отдых, работа, 3D, графика и многое другое.

Поэтому я сразу объясню что входит в оптимизацию, и почему меня раздражает, когда оптимизацией называют то, что к ней не относится.

1. Программно-аппаратная оптимизация. Сюда совершенно логично входят драйвера, однако их мы выделим отдельно, это важно. В данном случае это не посредственная настройка комплектующих через ПО и BIOS (Оверклокинг, температуры и другое): настройка видео чипа, настройка CPU, настройка RAM памяти, настройка накопителей — это база. Я могу добавить сюда ещё, но по сути этого достаточно, остальное уже не нужно, можно сказать даже больше, многим достаточно настроить электропитание CPU, тайминги RAM и драйвер GPU, или только последние;
2. Облегчение ОС, менеджмент данных и компонентов. Самый распространённый способ оптимизации, который не является обязательным, и нуждается в хорошем опыте и знаниях. Так как чаще всего на этом этапе ломают ОС. Сюда входит настройка данных (служб) ОС и её компонентов. Другими словами удаление/отключение "не нужных" служб, ПО и компонентов которые входят в официальный билд ОС. Данным методом можно хорошо облегчить ОС и высвободить много ресурсов для ПК, ускорить его работу, убрать не нужные, порой раздражающие функции и службы. Ну и конечно сломать свою ОС;
3. Настройка ОС и её отладка. Это самый обязательный пункт, да, ОС работает из коробки, однако очень часто её некоторые функции нам не нужны или работают не так как хотелось. Сюда входит всё, что настраивается в системе её же инструментами и настройками, без стороннего ПО или твиков;
4. Драйвера. Да, драйвера можно не только обновлять, некоторые из них ещё и настраиваются. Но тут нас больше интересует нужный пакет драйверов для нашего ПК и то, чтобы драйвера работали отлично. Об этом мы поговорим в проекте, у всех обычно драйвера — это установить/обновить. Но у многих с этим возникает куча трудностей. Драйвера — это очень важная составляющая ОС и напрямую от неё будет зависеть работоспособность ПК в целом;
5. И последние. Сторонние программы. Это крайне не устойчивый способ оптимизации, так как им можно сделать сильно лучше или сильно хуже. Сюда же относиться менеджмент задач и ресурсов, например как очищение закэшированной памяти RAM, что не делает почему-то ОС, выставление приоритет запущенным процессам в реальном времени, что тоже почему-то не делает ОС, а также многое другое. Пользоваться  _любыми_ программами с твиками крайне не рекомендую, дальше опишу почему.

В данном проекте мы поговорим непосредственно про пункт 2-5, то есть только то, что непосредственно относится к ОС, избегая других настроек и ПО, ибо они сильно индивидуальны, и поиск информации по ним лежит отдельно для каждого ПК.

Главный смысл моей оптимизации будет заключаться в понижение **задержки системы**, которая была полностью описана в проекте [Tomnor DLC] "Режим эксперта: задержка системы на продвинутом уровне".

## Почему твики — это плохо?

Я много лет использовал твики. И часто это не приводило не к чему хорошему, даже к полной поломке ОС без способов восстановления, хотя такое бывает крайне редко.

Твики можно и даже нужно использовать в некоторых случая, но соблюдая некоторые правила:
1. Мы знаем что такое реестр и как им пользоваться;
2. Мы знаем автора, или хотя бы что именно и конкретно делает данный твик, в том числе каким образом он это делает (можем прочитать скрипт);
3. Мы элементарно знаем что такое Windows Registry Editor

В противном случае как это часто бывает, мы исполним чужой не известный нам твик, который делает не понятно что и ломает реестр Windows, а его поломка или не корректность записи и не стабильная работа приводит к не приятным результатам. При том они могут быть не явные или появиться со временем, даже после обновлением компонентов Windows. Восстановление реестра путём инструментов ОС возможно, но оно работает не акхти, во многих случаях не спасает. Из-за чего мы вынуждены либо восстанавливать из резервной копии оригинал нашего реестра, либо переустанавливать ОС.

_Примечание_: последовательное выполнение/группировка этапов оптимизации не обязательна. Потому тут будет всё идти подряд, скажем так от начала и до конца, в ходе инструкции тот или иной метод, ПО, настройка будут относиться к той или иной ранее перечисленной нами группы.

Вся оптимизация была проведена на следующей сборке:

![Pasted image 20230923203728](https://github.com/user-attachments/assets/1a73d8d2-68d7-4a42-9572-fbd521f4d6f3)

_Также не забываем регулярно делать точку восстановления. И делать резервную копию реестра_. Открываем ранее скаченный архив и будем походу инструкции пользоваться им, во многих местах я не буду разжёвывать что и как мы делаем. 

---

## Обновление Windows

Да начнём наш ритуал! Переходим в скаченный ранее архив и начинаем с первого пункта в папке "Оптимизация". Перед началом не забываем делать резервные копии, которые можно сделать также через архив.

1. Конечно насчёт хейта обновлений много чего есть. Однако крайне рекомендую обновлять Windows регулярно, особенно после её установки, 90% проблем именно так и решаются, но и прибавляется конечно. Мы временно остановим автоматическое обновление (Временно приостановить обновление на 7 дней — кликаем несколько раз), но не в коем случае не при помощи хардкорного твика! Иначе будут проблемы со службами Windows, которые многим нужны, например Microsoft Store. Конечно же Windows должна быть активирована, кстати ключ стоит не дорого.

2. Отключаем доставку, ибо нам не нужно из своего ПК делать торрент.

![Pasted image 20231021142857](https://github.com/user-attachments/assets/8a7360b5-2e06-4d3a-b4ac-0680f6d8d5d6)

## Электропитание

Тут конечно можно сказать: Выстави высокую производительность и отключи пункт "отключения накопителей". Но я лучше буду пояснять каждый важный момент, чтобы было понятно зачем и для кого мы это делаем.

Стоит сразу сказать, что хоть технология ТБ (Turbo Boost) это не чисто софтовое решение, но сильно завязано на ОС Windows, и тут всё очень неоднозначно для тех, у кого оно не работает, так проблем и нюансов очень много. Например если мы говорим про mcupdate_Genuineintel.dll библиотеку которая отвечает не только за ТБ, — это патч (микрокод) от синих, который в целом ухудшает работу процессора, но как уже было сказано всё индивидуально, и возможно кому-то это напротив делает жизнь ярче и лучше. Поэтому мы опустим такие нюансы, так как саму технологию улучшить по сути нельзя, она либо работает как нужно, либо не совсем, либо не работает совсем. У тех у кого есть с этим проблемы, я добавлю отдельный пункт в конце **FixTB** — решение на уровне ОС. А пока что мы начнём с базовой настройки, которая всем известна. Меньше текста, больше дела, вот пресеты настройки электропитания:

![Pasted image 20231006184649](https://github.com/user-attachments/assets/0f189f3f-b82a-4c58-aa95-5bec402f43e0)

Вот "Экономия энергии":

![Pasted image 20231006184740](https://github.com/user-attachments/assets/f0134e68-5ae8-4660-a8ff-b033d50eb8c2)

А вот "Высокая производительность":

![Pasted image 20231006184824](https://github.com/user-attachments/assets/20d3af43-0ed6-4f3d-924d-7678d345b9bc)

Хочу заметить что эти схемы работают лучше, чем в Win 10. Но не об этом. Тут все максимально просто. Конкретно, наша ОС перестаёт сдерживаться в потребление энергии. Если нас интересует автономность на ноутбуке, то мы можем сами настроить данную схему под себя. Разбирать каждый пункт мы не будем, я бы рекомендовал лишь: "Отключить жесткий диск через": никогда.

Другие параметры могут не дать свой эффект, могут дать, это бывает по разному и в разных условия. Для ПК выставляем же "Высокая производительность" и больше нас это место не заботит.
Настройки электропитания:

![Pasted image 20231006185824](https://github.com/user-attachments/assets/35840dd6-8939-47bf-b4cf-b58da8a4dee3)

![Pasted image 20231006185841](https://github.com/user-attachments/assets/a5e2455b-02b2-45cf-ace1-55cf0f53c9cf)

![Pasted image 20231006185900](https://github.com/user-attachments/assets/55a710d2-0d81-4bf5-a1d6-fe70150618f5)

![Pasted image 20231006185923](https://github.com/user-attachments/assets/ac99ad99-dba2-44b7-9ac9-3e4daa4e85d3)

![Pasted image 20231006185939](https://github.com/user-attachments/assets/66135075-f810-41b9-8169-f027652fe37a)

![Pasted image 20231006190604](https://github.com/user-attachments/assets/4ff12a0a-f6e9-49e0-8211-db88fcb6f267)

Можно пойти дальше, и поставить себе схему питания **"Максимальная производительность"** .bat файлом из архива и проверить её настройки по скринам выше. Некоторые скрытые настройки поменяются. Но я бы не сказал что это хоть что-то даёт после моих тестов. Не рекомендую её включать для ноутбуков. Также не рекомендую использовать схемы из просторов интернета.

### Power Settings Explorer

Мы можем глобально настроить электропитание через программу **Power Settings Explorer**. Скажу сразу, данной программой я полностью не владею. Изменять параметры в ней может привести к сбоям, поэтому если вы её видите в первый раз, то рекомендую не использовать.
Это программа представляет из себя утилиту на Net 4.5 и использует для выполнения работы только [функции управления питанием из Win API](https://msdn.microsoft.com/en-us/library/windows/desktop/aa373163(v=vs.85).aspx).
о есть она меняет напрямую параметры электропитания в реестре. **Особенности:**  
- Колонка "hidden" в основной сетке получает и устанавливает видимость настроек в системном диалоге с расширенными настройками питания.  
- Значения можно редактировать во второй сетке (не нужно раскрывать их и переходить в диалог расширенных настроек схемы управления питанием Windows).  
- Настройки с отредактированными значениями отображаются жирным шрифтом.  
- Двойной щелчок по главной сетке открывает regedit и перемещает его к ключу для этой настройки в "HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Power\PowerSettings\SubGroupGuid" - но для этого вам нужно запустить утилиту от имени администратора.  
- Двойной щелчок по второй сетке на колонке со схемами вызывает диалог с расширенными настройками с выбранной схемой.  
- Экспорт и импорт настроек через кнопки внизу.  
- Создание bat-файла с командами powercfg для текущих изменённых настроек.  
- Столбец "active" во второй сетке получает и устанавливает текущую активную схему питания.  
- При нажатии Ctrl+F в основной сетке отображается панель инструментов поиска с полем редактирования для поиска шаблона, кнопками для поиска следующего, предыдущего появления шаблона, кнопкой для скрытия панели инструментов поиска; поиск производится только в ячейках столбца "current"; поиск не чувствителен к регистру; Поиск осуществляется с использованием регулярных выражений ([Regular Expression Language - Quick Reference](https://docs.microsoft.com/en-us/dotnet/standard/base-types/regular-expression-language-quick-reference)), поэтому шаблоном может быть как простое слово/часть слова/словосочетания, так и регулярное выражение.  
- Редактирование настроек для силовых оверлеев (при наличии).

![Pasted image 20231006191038](https://github.com/user-attachments/assets/b3167fce-5fd0-4418-92aa-f9981349f3ab)

Другими словами: выбираем параметр и настраиваем его отдельно для каждой нам нужной схеме электропитания. Нас интересуют следующие параметры:

1. Параметр временного отключения USB — запрещено
2. USB 3 Link Power Managment — off
3. Порог увлечения производительности процессора — ставим любое значение от 15 до 60. В обще не обязательный параметр настройки. Например 15 — означает что после 15% нагрузки процессора он увеличивает свою производительности на уровне ОС
4. Порог уменьшения производительности процессора — от 5 до 10
5. Разрешение состояния снижения питания — выкл. (если есть проблемы с питанием, то не трогаем)
6. Отключения простоя процессора — Отключить состояние простоя **ВАЖНО: ваш процессор всегда будет работать на 100%**

Всё. Незабываем нажать **Apple**. Там есть множество других интересных параметров, но к чему приведёт их изменения я увы не знаю. Для чего мы в обще это делали? Windows удивительная ОС и когда ты ей даёшь возможность что-то делать самостоятельно, она обязательно отключит тебе то, что нужно было, и не выключит то, что забирает ресурсы. Особенно это актуально для сетевых драйверов и режима работы процессора. В любом случае описание каждой функции присутствует в правом столбики, хотя сомневаюсь что оно вам что-то даст ^^

### Unpark CPU

Парковка ядер — интересный феномен процессора. С одной стороны этот параметр как бы паркует ядра для экономии Ватт, то есть парковка ядер подразумевает загрузку некоторых потоков центрального процессора и простой всех остальных. Естественно, это делается только тогда, когда физическое ядро способно справиться с такой нагрузкой. Все это в совокупности приводит к тому что в режиме простоя работает меньшее число ядер и, как результат, мы получаем меньшее энергопотребление, с другой стороны не существует идеальных алгоритмов и обязательно у тебя будет микро фриз в ответственный момент. По поводу этого момента ходят разные слухи. Я же предпочитаю отключать эту медвежью услугу.

![Pasted image 20231006200522](https://github.com/user-attachments/assets/a2e4124e-cfa3-4438-bac8-e92edbf28c89)

## Выключение гибернации

Гибернация удивительный режим, ибо он не выключает полностью ПК, что приводит к тому, что наша ОЗУ и лист ожидания не очищается, ибо оно восстанавливается обратно, учитывая что наша ОЗУ не имеет коррекцию ошибок, жди лаги. Конечно это можно делать вручную. Но данный режим по прежнему не понятен мне в своём существование, хотя есть предположение...

Используем твик от iosiph:

![Pasted image 20231006201118](https://github.com/user-attachments/assets/ac5d3aea-031a-4b6d-be23-3ea2f806bf19)

## Отключить UAC и smartscreen

Тут всё просто. **UAC** — контроль учётных записей пользователей, мы понижаем контроль, чтобы нам не мешали надоедливые уведомления от ОС при запуске некоторых программ и выполнение операций.

![Pasted image 20231007180905](https://github.com/user-attachments/assets/3d268871-a5c7-44bd-89ac-d53632fba3c2)

Для удобства будем использовать .bat файл:

![Pasted image 20231007180951](https://github.com/user-attachments/assets/ba03a6a5-35cd-484c-b507-29abc040a1e7)

**SmartScreen** — он нам уведомляет о запуске нежелательного ПО, который мы установили (или хотим установить). Толку от этого уведомления нету никого, оно даже не даёт никакой информации о том, почему оно считается угрозой. Чаще всего это происходит из-за отсутствия сертификации Microsoft, очень схоже с Google Play и сторонними приложениями на Android. Но вроде как в Win11 это дело прокачали, и теперь оно работает гораздо лучше. Но в таком случае нет лучше антивируса чем Вы сами, ну или ClamAV

## Установка компонентов ОС

Можно устанавливать по разному, можно установить разные библиотеке Net, можно установить дополнительные компоненты. Было бы отлично иметь скрипт, который может всё и сразу, но к сожалению он есть, правда не для чистой ОС, а для кастомной сборке от Ghost Spectre, однако я знаю способ как это сделать, но не гарантирую что это будет работать на 100%, поэтому у нас будет два варианта.

## Установка C++ & DirectX

1. Из нашего пака: **tomnorWin11\Оптимизация\4) Установка компонентов** — устанавливаем **DirectX**
2. Устанавливаем пакет: **Visual C++ Redistributable Runtimes All-in-One** by W1zzard (не забываем проверить актуальную версию)
3. На этом базовая установка завершена, однако _не всегда_ этого достаточно, поэтому идём дальше, кому нужно и кто хочет конечно.
4. Устанавливаем доп. пакет: **VC_redist x86 & x64**
5. Устанавливаем библиотеку **RuntimePack**
6. Перезагружаем ПК, в обще не забываем это делать после каждого этапа!
7. Ну и в заключение ставим **Ghost Toolbox**, для этого:
	1. Распаковываем файл
	2. Копируем **nhcolor.exe** в папку "C:\Windows\System32"
	3. Папку **Ghost Toolbox** копируем в директорию диска C:\ 
	4. Запускаем файл: "**update.cmd**" от админа 
	5. Запускаем файл: "**run.ghost.cmd**" от админа и ждём загрузки скрипта (если ничег оне происходит ну очень долго, то сначала запускаем "**update.cmd**" от админа, ждём некоторое время и пробуем запустить "**run.ghost.cmd**" вновь)
 
![Pasted image 20231007193119](https://github.com/user-attachments/assets/8ee45cf9-ff94-48ac-9237-25ccad1f893d) 
.
	6. Как мы видим, это лучший инструмент что я в обще использовал в жизни. Мы ещё к нему возможно вернёмся, но нужно закончить. Вводи "99" — обновление
	7. Вводим "30" — библиотека .NET
	8. Там мы можем включить старую библиотеку 3/2 — 1, но это очень редко нужно. Так же включить 4 версию, что тоже бывает не всегда нужно, только при особых настройках ОС — 7, включать их или нет, вы выбираете сами
 
![Pasted image 20231007193448](https://github.com/user-attachments/assets/3ad5ae4e-2931-4b0a-8a7a-35166ac06678)
.
	9. По возвращению в главное меню вводим "16" — актуальная версия .NET. Тут мы можем выбрать установить весь пакет — 1 или только последние актуальные — 2. Многие из них и самые важные мы уже установили, но я предпочитаю ставить все версии, ибо редко но метко бывает, что какой-то версии издания нету, а потом приходится искать её
8. Перезагружаем ПК

## Параметры Windows

Настройки Windows могут растянуться на долго, не все пункты обязательны. Например у меня стоит уже сборка с не _вырезанным защитником_, а *отключённым*. Буду обращать на это внимание постоянно: **не нужно _вырезать_ встроенные компоненты в ядро Windows какими-то там твиками**

1. Отключаем защитник Windows при помощи твика от iosiph через приложение "**PowerRun**", для этого достаточно перенести .reg файл в него (**ВНИМАНИЕ!** На новых сборка Windows данный твик замедляет работу проводника или заставляет его не отвечать, пока что я не понимаю с чем это связано, скорее всего баг ОС. Поэтому для его отключения придётся пользовать ПО, что часто блочится, либо отключать ручками, что делает это не доконца. В общем заподня. В архиве будет актуальное ПО, использовать на свой страх и риск)

![Pasted image 20231007200036](https://github.com/user-attachments/assets/6b6b401c-afe3-40b1-b756-c9960a903397)

2. Отключаем патчи Spectre, Meldown, Tsx (**ВНИМАНИЕ!**). **Патч Meldown** — актуален для старых процессор Intel. **Патч Spectre** — По сути, каждый высокопроизводительный процессор, когда-либо созданный — Intel, AMD, ARM и POWER — считается уязвимым. Подобно Meltdown, атака Spectre злоупотребляет спекулятивным выполнением, чтобы получить информацию, которая должна быть изолирована. Файл реестра **Tsx** — включает защиту от перезаписи обработки структурированных исключений (SEHOP) в операционных системах Windows. Эта функция предназначена для блокирования эксплойтов, которые используют метод перезаписи SEH. Такой механизм защиты предоставляется во время работы. Таким образом, это помогает защитить приложения независимо от того, были ли они компилироваться с помощью последних улучшений, например /SAFESEH.

3. Мы можем проверить, защищён ли наш процессор от первых двух уязвимостей  при помощи программы — **inspectre**

![Pasted image 20231007201251](https://github.com/user-attachments/assets/b0b57d7a-be01-461f-a3ab-da366f46b796)

У меня например этой защиты нету, ибо процессор старый, на новых эти уязвимости исправили. Также сказано что у меня включен патч:

![Pasted image 20231007201436](https://github.com/user-attachments/assets/0c75b9a0-4ae5-4027-ac24-756e61123513)

Так вот, дело в том, что данные патчи — это костыли в ОС Windows, которые должны защищать наш ПК от этих уязвимостей, правда ценной оптимизации. Поэтому только тебе решать, отключать твиком эти патчи и функцию Tsx или нет. Скажу сразу, если это сделать для домашнего ПК, то можно быть уверенным в том, что с 98% вероятностью проблем не будет, если тебя не закажут конечно. Поэтому лично я выключаю эти патчи при мощи твика от iosiph, или через сам **inspectre**:

![Pasted image 20231007201825](https://github.com/user-attachments/assets/9eb54482-8cd7-41c5-9fc8-471e1c449203)

3. Отключаем Брандмауэр Windows

![Pasted image 20231007202048](https://github.com/user-attachments/assets/7fa64031-92c5-44ae-aef8-8dcabfb05fd5)

![Pasted image 20231007202103](https://github.com/user-attachments/assets/99d92fe1-3088-44b2-826b-71821e0ed52d)

4. Выключаем назойливое уведомление безопасности:

![Pasted image 20231007202509](https://github.com/user-attachments/assets/c98078c1-3343-45f2-926c-2476078bbcd8)

5. Отключение VBS. Это новая фишка Windows 11, на 10 её нету. Если коротко то VBS – это функция аппаратной виртуализации, которая создает и изолирует от остальной ОС безопасную область в ОЗУ. Windows может использовать эту изолированную безопасную область памяти для хранения важных для безопасности данных и кода. Отключать эту функцию или нет, решать тебе. Хотя если выключен антивирус, то она тоже отключается:

![Pasted image 20231009182650](https://github.com/user-attachments/assets/f8d4c9c3-7b35-42dc-b5ab-ea33a375f749)

По некоторым данным она жрёт производительность, что не удивительно, хотя если у нас быстрая и большая память, то я не думаю что она будет как-то препятствовать производительности. Для её выключение используем твик от iosiph:

![Pasted image 20231009183001](https://github.com/user-attachments/assets/d40f6611-a203-458e-90d0-3d6b10cbc63a)

### Настройки мыши

Конечно если у тебя супер крутая мышка g102, то обязательно устанавливаем драйвера на неё, а дальше по пунктам:

1.  Выключение акселерации

![Pasted image 20231007202706](https://github.com/user-attachments/assets/7dd4c113-a97b-4ceb-9cda-756ad1be2b93)

2. Масштаб — убеждаемся, что там 100%. Не актуально для 11 версии ОС, старый баг

![Pasted image 20231007202826](https://github.com/user-attachments/assets/b3419f12-4e93-45b4-8912-c1cc2b41d336)

3. Быстрый твик по настройки мыши в Windows:
	1. HKEY_CURRENT_USER\Control Panel\Mouse — тут мы меняем параметры, что я указывал выше, то есть отключаем ускорение мыши. Также мы снижаем тайминг наведения указателя: **MouseHoverTime**
	2. Я оставил параметр SmoothMouseXCurve и SmoothMouseYCurve в настройках 1 к 1, для Windows 11 это не актуально. А было актуально для 10, где при смене масштаба херилась разница между физическим перемещением мыши и перемещением курсора зависимости от масштабирования экрана
	3. Буфер драйвера мыши мы трогать не будем, менять его смысла нет, ибо он динамический.
	4. ThreadPriority — Выставим обработку драйверов клавиатуры и мыши в режиме реального времени (не уверен в работе этого параметра, однако мы к этому ещё вернёмся)
	5. HKEY_CURRENT_USER\Control Panel\Accessibility — отключим дополнительную задержку при нажатии клавиш мыши и клавиатуры, а также уберём залипание при двойном нажатии Shift. **Не рекомендую использовать для ноутбуков**

![Pasted image 20231007205936](https://github.com/user-attachments/assets/ae16d0bf-9d0b-425d-a591-ffc8b1ad4fd3)

#### Немного про DPI

У мышки есть несколько важных параметров, которые нужно учитывать:
DPI — это сенса? Какая-то своя частота опроса? Разрешение сенсора? Дело в том, что это очень важный показатель, грубо говоря, как мы знаем например если у нас стоит 400 DPI, это значит, что при перемещении мышки на 1 дюйм курсор переместится на 400 точек по экрану. Вы спросите, и что с того?

![image](https://github.com/user-attachments/assets/ae637044-0c0f-497a-91fa-92e138720c0d)

Дело в том, что сенсор по факту отправляет физический сигнал ПК при передвижении на 1/400 дюйма, тогда как при 1 600 DPI, это уже 1/1 600. Ну так и что с того?

![image](https://github.com/user-attachments/assets/0d738e66-cd91-4e87-88f6-6a0689d9a01c)

А дело то в том, что тут математиком не нужно быть, чтобы понять, что если у нас две мышки 400 DPI и 3 200 DPI, то при передвижении её на 1/400 дюйма, мы получаем: 400 DPI — один сигнал; 3 200 DPI — восемь сигналов. И тут начинается самое интересное, давай представим две ситуации:
1. Мы двигаем мышкой очень медленно, тогда получается:
1) t1 = 1sec/400 = 2.5 ms, т.е. при 400 DPI мышка будет отправлять сигнал каждые 2.5 ms
2) t2 = 1sec/3200 = 0.3 ms, т.е. при 3 200 DPI мышка будет отправлять сигнал каждые 0.3 ms

Разница кажется большой, однако вспоминаем про частоту опроса, обычно это 1 000 hz, тогда мы упираемся в этот показатель, так как там сигнал передаётся каждые 1ms, тогда это становится узким местом.

2. Мы двигаем мышку быстро, например делаем snap aim, флики, тогда представим что это скорость примерно 2м/c — стандартная тема при которой современные сенсоры, да и старые не получится сорвать:
1) t1 = 1sec/400 = 0.025 ms, т.е. при 400 DPI мышка будет отправлять сигнал каждые 0.025 ms, так как V = 100inch/sec
2) t2 = 1sec/3200 = 0.003 ms, т.е. при 3 200 DPI мышка будет отправлять сигнал каждые 0.003 ms, так как V = 100inch/sec

То есть другими словами, получается так, что скорость увеличивается в ~100 раз, и соответственно, обновление сенсора происходит чаще.

И тут возникает другой вопрос: к чему это всё? Разница же маленькая. Дело в том, что так оно и есть, да при повышение частоты опроса скажем до 2 000 - 4 000 hz мы можем уменьшить инпут лаг, однако это не играет особой роли, тем не менее, есть нюансы и сейчас я о них расскажу, это была вводная информация. Поговорим про пропуски пикселей. И для начала я задам встречный вопрос. Вот ты играешь на 400 DPI и тебе это нравится, но почему именно 400 DPI?

Когда мы говорим про чувствительность, нам стоит понимать разницу между настройкой чувствительности в игре и DPI. Где DPI это вполне рабочая физическая величина, отвечающая за работу сенсора, а сенсор это по сути (лазерный или оптический) устройство, которое берёт информацию и перемещение с поверхности. В то время, как чувствительность — это программный код, где не всё так однозначно. Так как передать физический сигнал — это может быть эффективнее и производительнее, чем то, как программист написал движение прицела или курсора на игровом движке, и то как это обрабатывается. Другими словами уверен ли ты, что 400 DPI это хорошая идея?

![image](https://github.com/user-attachments/assets/689a4d0c-45c3-4fd0-9853-e57830e34339)

Так что же там за пропуски пикселей?
Не все игры, умеют правильно наращивать чувствительность в игре, кроме того, не всегда это функция в принципе работает нормально и потенциально написано не для всех игроков корректно, я про то, что если ты играешь с низкой сенсой, бывает что она может быть ниже 1, кроме того, это может быть число в сотых для уже набитой руки по 4к часов в CS.

Теперь я приведу пример, вы можете его протестировать в игре:
1) При 3 200 DPI у нас скажем будет чувствительность —  4, что вполне адекватный показатель
2) При 400 DPI чувствительность придётся поднять в 8 раз, а это уже 32, многовато? Но так у нас будет такая же чувствительность как и при 3 200, не быстрее, не медленнее

И что получается? А получается то, что при таких значениях у нас всё также опрос сигнала остаётся 2.5 ms, но мы при помощи настроек игры увеличили чувствительность, что привело к пропускам пикселей, так как расстояние которое нужно преодолеть курсору/прицелу при 3 200 DPI и 400 DPI в игре должно сохраниться и быть одинаковым. Из-за чего прицел начинает двигаться рывками, зато это напоминает некоторую функцию в ПО для мышек, где можно заставить курсор двигаться в чётком направление не давая ему создавать кривую движения, что может в теории помочь наводить прицел из точки А в точку Б чётко по прямой, что так себе идея.

В результате я хотел рассказать про эту разницу, чтобы вы её понимали и как это функционирует, так как в целом проект просвещён задержкам и некоторым элементам что с ними связаны. Если вы играете на 400 или 800 DPI, рекомендую просто попробовать поднять это значение хотя бы в 2 раза, и возможно именно тебе так зайдёт больше. 

### Приложения

Это больная тема, особенно для меня. Удаление любых приложений идёт на ваш страх и риск.

1. Устанавливаем замечательную программу: **Revo Uninstaller**. Крайне рекомендую использовать только её при удаление любых ПО.
2. Удаляем приложения Windows через неё. **НЕ рекомендую удалять**: Notepad, paint, Terminal, калькулятор, ножницы, Store, Edge, фотографии, Windows Web, и любые кодеки.

![Pasted image 20231007211449](https://github.com/user-attachments/assets/1d894c5b-d90c-4f7b-865f-927b51b34602)

Также можно воспользоваться программой **O&O AppBuster** — она как раз предназначена для удаления приложений Windows, таких как будильник, новости, кортана, OneDrive и т.п.

![Pasted image 20231007212108](https://github.com/user-attachments/assets/d5088901-e0d8-4f7c-82cc-92adb1e5605e)

3. Останавливаем работу приложений в фоне — для Windows 11 используется твик от iosiph

![Pasted image 20231007212524](https://github.com/user-attachments/assets/71c94c8f-937e-4bb1-854c-208abcb562d9)

4. Чистим автозагрузки
5. Отключаем установку карт в фоне

![Pasted image 20231007212817](https://github.com/user-attachments/assets/aba85c32-c281-4b98-a28b-be132153de32)

6. Отключаем автообновление приложений Store в настройках. Если стоит нова ОС, не забываем перед этим проверить обновления

![Pasted image 20231007212943](https://github.com/user-attachments/assets/eec2758a-af29-4a91-b117-c0ad33447bc6)

### Остальные настройки

1. Включить GameMode. Также настраиваем параметры графики

![Pasted image 20231007213309](https://github.com/user-attachments/assets/149f94e9-d093-4757-addf-55a0696b2b30)

2.  Параметры быстродействия — настраиваем на свой цвет и вкус. Чем меньше красоты, тем больше скорость работы. После чего переходим во вкладку "Дополнительно" и настраиваем виртуальную память:

![Pasted image 20231007213526](https://github.com/user-attachments/assets/19f89733-c2de-4735-aad5-22068154fdc1)

Значит так. Как это работает? У нас есть ОЗУ, там хранится всё что обрабатывает CPU, очень многое из этого не нужно нам в самой быстрой памяти ПК, поэтому есть файл подкачки. Его рекомендую создавать на самом быстром накопители, туда будут сохраняться временные файлы вместо того, чтобы грузить ОЗУ. Какой размер выбрать? Зависит от конфигурации ПК, хочу заметить, что есть поставить 65Gb, то они пропадут с диска на котором был указан этот размер. Ставить слишком мало 124 Mb, нет смысла. Поэтому опираемся на:
1) Объём накопителя
2) Объём доступной оперативной памяти

Я всегда интуитивно ставлю 1/2 от общего объёма оперативной памяти, если она больше 8ГБ, если ОЗУ <= 8 Гб, то ставлю файл подкачки 100-200% больше от общего размера. То есть например у нас 8Гб, значит файл подкачки будет: от 8 192 Mb до 16 384 Mb.

_Файл подкачки очень часто используется профессиональными программами, типа Adobe. Они могу при больших проектах съедать огромное кол-во памяти, некоторые свои данные они грузят и сохраняют именно в файле подкачки, а не в ОЗУ_

3. Отключение службы **SysMain** — если не впадать в подробности. То рассмотрим такую ситуацию, твоя игра загружена на SSD, но какая-то программа которая работает в фоне, например Steam стоит на HDD, при играх бывают фризы. Или даже просто используя ПК, ты смотришь в дисп. задач, а там какая-то SysMain грузить твой HDD под 100. Дело в том, что она оптимизирует работу HDD и используемые на нём файлы. В действительности она ускоряет работу Steam, а точнее его загрузку, но когда она начинает работать в фоне, она может создать разные ситуации когда другое приложение или игра начинают лагать. Поэтому её отключение зависит от тебя. Если HDD нету, то смело её выключаем.

![Pasted image 20231007215019](https://github.com/user-attachments/assets/3f236170-3a1c-4d99-ba48-31f273e35e24)

4. Выключаем индексацию. Откровенно говоря алгоритм индексации Windows полное говно и ещё и работает в фоне. Поэтому крайне рекомендую для поиска любых файлов и папок использовать программу "**Everything**". Отключаем индексацию на всех дисках:

![Pasted image 20231007215400](https://github.com/user-attachments/assets/62552606-d1b6-4bf3-9904-301fb1d85a59)

Для этого ПКМ по диску —> свойства, и снимаем галочку на разрешить индексацию. После чего нажимаем "Применить" и в открытом окне "Отмена" ибо он начнёт индексирование всех файлов перед выключением.

5. Отключаем ш-п-и-ооо-н-о-в твиком от iosiph

![Pasted image 20231007215745](https://github.com/user-attachments/assets/d6115168-2f9a-4284-afea-2584a5505ef1)

6. Отключаем трригеры и службы  ш-п-и-ооо-н-о-в .bat файлом от FadeMind

![Pasted image 20231007215907](https://github.com/user-attachments/assets/126cd3e3-e498-4092-acfa-9102b7975ce0)

7. Дополнительно отключим предупреждения при запуске любых .exe твиком "Отключение уведомлений безопасности.reg"

![Pasted image 20231017194347](https://github.com/user-attachments/assets/e15988ca-9595-4179-b9d4-b9b7d11a2a73)

8. Мы также можем полностью отключить UAC (контроль учётных записей), что делает нас абсолютным администратором (или не совсем ^^). Однако лично у меня бывали очень редкие случае, когда это не давала запустить приложение. Это можно сделать при помощи твика "Полное отключение UAC.reg"

![Pasted image 20231017194836](https://github.com/user-attachments/assets/9f5b7283-ebe5-4dc4-a054-b001ae9af958)

9. Перезагрузка ПК

## Оптимизация накопителей

Если ОС стоит новая, то тут мы сделаем совсем немного. Если же она не новая, то смотрим и изучаем:

1. Очистка устройств. Через программу "**Device Cleanup Tool"** мы будем чистить список устройств, которые были когда-либо подключены к ПК. Это делается чтобы убрать лишние и вычистить это из системы, редко, но бывают проблемы с этими устройствами или с другими, ибо они занимают порты, хоть это всё условности:

![Pasted image 20231009180214](https://github.com/user-attachments/assets/7fd6f180-188e-4d69-aa86-2cc5b089a5e3)

В программе мы видим все устройства, который в данный момент не используются. Можем смело их выделять и удалять все, даже если вы регулярно подключаете флешку, с ней всё будет хорошо и она спокойно подключится. _Рекомендуется делать это регулярно_

2. Очистка дисков. Встроенным инструментом очистки я бы рекомендовал пользоваться постоянно. Ибо он действительно чистит всё, там так же есть выбор. Сторонние ПО при не опытном использование может удалить то, что потом пригодиться: кэш, обновления, "мусор" реестра, точки восстановления и многое другое. Не забываем периодически чистить папку "Temp" 
3. Включаем опцию TRIM. Не будем впадать в подробности того, как это работает, но если коротко то ОС с помощью команды TRIM сообщает накопителю, какие блоки уже не нужны и их можно стереть — не дожидаясь записи. Если этого не делать, то твердотельный накопитель со временем начнет терять скоростные показатели. Для этого используем простецкий .bat файл
4. Выполняем дефрагментацию накопителей и оптимизацию, думаю и так все знаю для чего этого. Можно использовать разное сторонние ПО [Defraggler](https://www.ccleaner.com/defraggler?cc-noredirect=), [Auslogics Disk Defrag](https://www.auslogics.com/ru/software/disk-defrag/), зачастую его алгоритмы дефрагментации более эффективные, но можно спокойно обойтись инструментами ОС, которые кстати работают быстрее. _SSD не рекомендую дефрагментировать_

![Pasted image 20231009181953](https://github.com/user-attachments/assets/872069e6-56ab-4e99-8586-8727cbad052b)

## Высокоточный таймер — HPET

**HPET (High Precision Event Timer)** — высокоточный таймер, который стал использоваться в ОС вместо стандартных часов реального времени. Основное преимущество от этого получают мультимедийные приложения и программы, обрабатывающие поступающие данные в реальном времени.

В общем, если понятным (не совсем) языком. То если мы обратимся к моему проекту [Tomnor] в котором я объясняю работу конвейера ядер и процессора, то мы можем понять, что выполняемые инструкции процессором работают через такты. Дело в том что таймер, который работает непосредственно с тактами с 2005 года внедряется в чипсеты intel на аппаратно-программном уровне и работает через логику (компараторы), которая вызывает прерывания. В обще это важная функция для работы ПК, грубо говоря она экономит время работы тактов процессора при выполнения сценариев, что увеличивает производительность и снижает энергопотребление, **отключать** эту функцию нельзя. Но алгоритм HPET в ОС работает с определённым таймингом примерно в 15 ms, нужен в ОС он по большей части для работы служб и планировщика, алгоритм этого кода весьма сложный и состоит из устройств, о чём мы говорили ранее. Но как и с любыми таймингами есть один нюанс: всё что попадает между тактами не выполняется и ожидает новой временной метки. Поэтому зачастую, уменьшая данное время мы улучшая отзывчивость ОС, тем самым понижая её задержки. Однако мы не сможем заставить всегда работать с низкой частотой опроса, по сути мы выставим два режима работы: медленный и быстрый.

И прежде чем продолжить, если  Вы решили отключить **HPET** в ОС, то обязательно проверьте, чтобы он был включен в BIOS (кварцевый генератор), или наоборот. Первый вариант лучше, так как **HPET** — по сути эмулирует таймер, который у нас и так есть нормальный и рабочий. Лаги он вызывает как я уже выше сказал из-за "Системных прерываний"

Если мы проверим работу таймера:

![Pasted image 20231009184905](https://github.com/user-attachments/assets/5217defd-f7c5-4313-9d58-ac6477324465)

Тут можем видеть, что он работает от 0.5 до 15.6 ms. Снизу написано с каким таймингом работает таймер в данный момент. Таймер является условно динамическим, и мы можем зафиксировать его работу на самом минимальном значение 0.500 - 1 ms.

Для этого нам нужно отключить функцию, а точнее устройство которое заставляет работать его в динамическом режиме. _P.s. если у нас не включена не одна программа, то он в любом случае будет работать с таймингом в 15.6 ms_.

1. Для Windows 10 ставим .bat который отключает dynamic tick. В 11 с этим всё в порядке
2. Используем .bat файл для его полного отключения в системе (dynamic tick, synthetic timers, platform clock):

![Pasted image 20240820182332](https://github.com/user-attachments/assets/d041d9e2-3dbd-4f20-90d0-c02a4ed871be)

3. Отключаем драйвер (устройство) — Высокоточный таймер событий: диспетчер устройств —> Системные устройства —> Высокоточный таймер событий:

![Pasted image 20231009190425](https://github.com/user-attachments/assets/63b23704-b994-4425-a0b8-785b11ab98f0)

4. Дополнительно мы можем загрузить свой таймер при про помощи скрипта "**STRservice Install 3**". Его делать *не обязательно*, по некоторым данным, если таймер будет работать на 0.5 ms, а не 1 ms, то могут напротив возрасти задержки. Однако это связано с чипсетом и процессором ПК.
	1. Для этого заходим в папку и запускаем "Installer.bat"
	2. Тут мы можем установить версию C++ и C#, удалить их, а также запустить STR и выключить его. Разница между C++ и C# не только в языках (да), а в алгоритмах работы, мы воспользуемся C++, в редких случаях нужен C# — вводим "4"
	3. Потом запускаем STR (если он почему-то не включился) — вводим "6"
	4. И можем проверить работу таймера — вводим "8"
 
	   ![Pasted image 20231009191249](https://github.com/user-attachments/assets/ebe1a8a3-436e-4640-9dcf-c0e8f788703f)

	   Если не вышло, то перезагружаемся. Сам скрипт не удалять, и не выключать в планировщики. *P.s. C# — этот алгоритм как раз подстригает пользователя от более больших задержек из-за процессора, если твой проц попадает в чёрный список, то таймер не устанавливается сам и остаётся на 1 ms*

    ## Нужно ли отключать FSO?

**FSO** — Fullscreen Optimizations. В общем, весьма интересная вещь, в обще она полезная, если быть совсем кратким, то данная опция ОС позволяет во время полноэкранного режима пользоваться преимуществами оконного, однако по некоторым данным, данная функция создаёт проблемы и негативно влияет на чувствительность мыши. Как говорят блогеры — нельзя сказать, что в полноэкранном режиме у нас всегда оконное и Microsoft нас наебало, чисто технически в ОС это реализовано проще и просто позволяет использовать интерфейс, например ползунок громкости в полноэкранном режиме. Сами синие написали небольшую статью по этому поводу [Demystifying Fullscreen Optimizations - DirectX Developer Blog (microsoft.com)](https://devblogs.microsoft.com/directx/demystifying-full-screen-optimizations/) 

Давай простым языком. надо оно мне или нет? Симулируем две ситуации:
1) Ты делаешь ALT + TAB или вызываешь игровой оверлей, в этот момент у тебя начинаются лаги и баги — это так работает FSE в некоторых играх (полноэкранный режим), так получается потому что мы, во-первых, переключаем контроль с одной задачи на другую: игра - рабочий стол; во-вторых, GPU не параллелит рендер нескольких окон, он либо рендрит рабочий стол - оверлей, либо игру.
2) При выключенном FSE (любой другой режим), у нас всё круто, однако мышь начинает плавать. Это из-за того, что в играх часто используется полная привязка, которая не (пытается) транслироваться с привязки движения мыши ОС

И вот эти две проблемы от игры к игре могут быть ярко выражены, а могут нет. Режим FSO — это золотая середина, скажем так логическое улучшение FSE.

На самом деле, отключать FSO нет смысла, но а зачем? В большинство современных играх он несёт пользу. Если же он не корректно работает с какой-то игрой или приложением, мы можем проделать простые действия:

1. Ищем .exe файл приложения/игры
2. ПКМ —> свойства —> совместимости
3. "Отключить оптимизацию во весь экран"

![Pasted image 20231010205549](https://github.com/user-attachments/assets/1364084e-379d-45a3-bc6b-d90b5b73d1f0)

Готово. Данная функция существует уже 100 лет. Но люди очень "умные", поэтому будут искать способы отключить всё, что им кажется работает не так как хочется. 

## Драйвера

Прежде чем продолжить, нам нужно познакомится с этой темой. Что нам нужно знать про драйвера?

1. Новые драйвера не всегда хорошо работают;
2. Драйвера можно настроить, так как они имеют аппаратно-программную составляющею;
3. Кривые драйвера ухудшат работу системы: не нужно обновлять драйвера сторонними программами, если мы не знаете какие драйвера вам нужны;
4. От драйверов напрямую зависит задержка системы и общая производительность работы ПК.

Для начала устанавливаем все драйвера от производителя. Если вы не понимаете что это означает, то что вы тут в обще забыли?

Дальше нам интересуют типовые драйвера, если мы их не установили или хотим их поменять: сетевой драйвер, драйвер видеокарты, драйвер звука. Так как моя система преимущественно Intel + Nvidia, то я буду показывать на их примере, если у вас что-то другое, то Google в помощь, сорри, я с другими не работал, поэтому ручаться за это не буду.

1. Перед тем как работать с драйверами, мы **отключаем автообновление драйверов**, потом можно будет включить обратно при помощи твика от iosiph
2. **Интернет**. Если по какой-то причине мы не нашли свой драйвер у поставщика адаптера, то мы можем воспользоваться паком драйверов от iosiph. Однако он старый, я пройдусь по двум самым популярным адаптерам отдельно, но пока что посмотрим как нам установить распакованный драйвер из пака: 
	1. Разархивируем "Разархив. Дрова.zip";
	2. Заходим в диспетчер устройств —> Сетевые адаптеры;
	3. Если у нас там несколько адаптеров, то воспользоваться моим батником "info adapter.bat"
 
	   ![Pasted image 20231010212337](https://github.com/user-attachments/assets/e448f152-49c2-4ea7-a19a-5c8ea0de4d03)

	   4. Тут мы видим название нашего основного адаптера сети. Его же ищем в диспетчере устройств: ПКМ —> свойства —> драйвер —> обновить драйвер —> Найти драйвер на этом компьютере
	   5. Прописываем в поле полный путь к распакованному ранее архиву и нажимаем "Далее"
    
	   ![Pasted image 20231010212649](https://github.com/user-attachments/assets/f5773ebb-b8f3-4bb8-856b-1136bbe66b68)

	6. После чего начнётся автоматический поиск и установка драйвера для этого устройства.

**Что нам делать, если нужен новый драйвер?**
1) Определяем наш адаптер через тот же .bat, если это
	1) Семейство **Killer**, то мы скорее всего можем найти этот драйвер на официальном сайте производителя нашей мат. платы, или ноутбука. Либо посмотреть на [Support for Intel® **Killer**™ **Ethernet** Controller](https://www.intel.com.au/content/www/au/en/support/products/215299/ethernet-products/intel-killer-ethernet-products/intel-killer-ethernet-controller.html)
	2) Семейство **Realtek**, то переходим на оф. сайт [Realtek](https://www.realtek.com/en/component/zoo/category/network-interface-controllers-10-100-1000m-gigabit-ethernet-pci-express-software) тут мы можем увидеть актуальные драйвера для разных моделей RTL8*** где выбираем автоустановщик в соответствие со своей ОС, в нашем случае это "Win11 Auto Installation Program"

3. Сразу настроим наш новый сетевой адаптер. Перед этим не забываем перезагрузиться:
	1. Отключаем энергосбережение адаптера — это как и с настройками электропитания CPU и USB которое мы делали: диспетчер устройств —> сетевые адаптеры —> наш адаптере ПКМ —> свойства —> Дополнительно —> параметр "Зелёный Ethernet" — "Выкл"
	2. Далее, устанавливаем включаем "**TCP Optimizer**" от админа (*в обще всё в этом гайде включаем от админа*), далее настраиваем адаптер через эту программу:
		1. Можем ничего не трогать и просто выставить пресет "Optimal"
		2. Далее настраиваем параметр "Connection Speed" (ползунок), по-умолчанию стоит 10 Mbps, на самом деле его можно не трогать, но вдруг у вас супер быстрый интернет, поэтому смело выкручиваем на 100+ Mbps
		3. Далее нажимаем "Apply changes"
		4. Ставим бокс "Backup" —> "Ок"
  
		   ![Pasted image 20231010220842](https://github.com/user-attachments/assets/6aeeb420-ca05-423d-99b9-c2a8d6c77050)

		   5. Перезагружаемся в появившимся окне после успешных изменений реестра 
	3. Теперь настроим **DNS**:
		1. Устанавливаем программу "**dns-jumper**" (ВНИМАНИЕ там реклама, не забываем нажимать "Пропустить")
		2. Далее пингуем DNS сервера при помощи программы "**DNSBench**". Для этого запускаем её и нажимаем на вкладку "Nameservers" —> "Run Benchmark". Мы можем добавить новые DNS сервера и проверить их тоже, например RU аналоги, если вам хочется, или другие DNS. Но воспользуемся стандартным списком.
		3. После завершения в появившемся окне нажимаем "Tell Me More"
  
		   ![Pasted image 20231010222844](https://github.com/user-attachments/assets/08ba8b16-d1ef-41d1-bfb0-4e1826d031b8)

		4. Переходим во вкладку: **Tabular Data**. Тут мы видим все характеристики DNS серверов которые мы пинговали. А именно их минимальную и максимальную задержку, также пропуски
  
		      ![Pasted image 20231010223139](https://github.com/user-attachments/assets/0403cf72-a9a8-4644-9184-c790bbc8299c)

		5. В данном списке нас интересуют первые два DNS сервера, а именно: 192.168.0.106 и 1.1.1.1 (у вас могут быть другие). Возвращаемся в программу **dns jumper**
		6. Там вводим наши DNS сервера в поле, если один будет тупить, то второй сработает как резерв. После чего применяем настройку
		       ![Pasted image 20231010223820](https://github.com/user-attachments/assets/e85197f4-e42e-4099-9ad4-cf41ca93e1c3)
	 
		7. Перезагружаемся.
4. **Звук**. Тут всё просто, но бывает что возникают трудности:
	1. Для начала обновляем драйвер на оф. сайте. Даже если стоит свой аудио адаптер от производителя, то там все равно используется чип Realteck, поэтому нужно установить и драйвер Realteck и драйвер (ПО) от производителя мат. платы/ ноутбука. [Тут](https://www.realtek.com/en/component/zoo/category/pc-audio-codecs-high-definition-audio-codecs-software) можно найти драйвер Realteck. Однако он не обновлялся сотню лет, да и скачка у них медленная, поэтому просто устанавливаем уже скаченный драйвер: "**0009-64bit_Win7_Win8_Win81_Win10_R282.exe**"
	2. Настройка звука. Тут можно делать что душе угодно. кроме одного момента: Переходим в настройки звука —> выбираем наше устройство —> Свойства —> Дополнительно
	3. Тут у нас есть формат звука. Оххххх, я бы мог поговорить про то как устроен и работает звук. Но скажем так, я уверен на 99% что ваши динамики не способны воспроизводить больше 44100 Гц и 16 бит. Дело в том, что более высокая настройка лишний раз грузит наш драйвер, а именно аудио чип Realteck, по моему проекту [Tomnor .hardware] мы можем узнать что он декодирует звук, грубо говоря, а значит выполняет вычислительную работу, собственно говоря выставляем параметры: **16 бит, 44100 Гц (Компакт-диск)** и радуемся. И да, это действительно влияет на производительность ОС и не только.
	4. Также рекомендую отключить лишние устройства, они нам не к чему.

## Драйвера видеокарты

Тут я решил выделить отдельно. Это очень большая тема. Начнём с теории. У нас есть драйвера на Nvidia, это целый пакет ПО, а не только сам драйвер. Я настоятельно рекомендую ставить только драйвер, без ПО, ибо всё это дело будет работать в фоне и грузить лишний раз GPU:

![Pasted image 20231010231114](https://github.com/user-attachments/assets/8e11da28-8a7d-4aa2-9cb9-e9b80f7aa236)

![Pasted image 20231010231217](https://github.com/user-attachments/assets/2cda72a8-b1ef-4f77-8343-e234dcdb31ea)

Неоднократно тесты от разных YT-беров показывало, что чистый драйвер выдаёт больше FPS. В таком случае тебе нужно сделать выбор:
1. Если тебе нужен весь этот софт от Nvidia, то просто скачивай официальный драйвер с сайта Nvidia и не парься.
2. Если ты хочешь максимум FPS, то добро пожаловать

---

1. Запускаем безопасный режим —> Загрузка —> Включаем "Безопасный режим"

   ![Pasted image 20231010231724](https://github.com/user-attachments/assets/d1d33de2-f9f8-48cd-8c20-d5ebb92733be)

2. Перезагружаемся. Теперь когда мы в безопасном режиме, то делаем всё в обратном порядке и отключаем его. **НО не перезагружаемся**
3. Запускаем программу "**Display Driver Uninstaller**" — она полностью удалит старый драйвер. Выбираем нашу видеокарту и нажимаем "Clean and restart"

   ![Pasted image 20231010232043](https://github.com/user-attachments/assets/06874c5b-8201-442d-b4e7-9c697bfadafd)

4. Далее установим чистые драйвера через программу "**NVCleanstall**" — она регулярно обновляется:
	1. Какой драйвер ставить? Версия драйвера также как и все драйвера ПК могут быть хуже или лучше, но я **рекомендую** ставить именно последнею версию драйвера, если мы играем в новые игрушки, так как они могут их требовать. Если мы задротим конкретную игру, то можем посмотреть лучшею версию драйвера для неё. Для выбора версии кликаем по "**Manually select a driver version**" и "Show all versions" —> выбираем последнею версию —> "Next"
 
	   ![Pasted image 20231010233208](https://github.com/user-attachments/assets/7661de08-f6a7-4618-9e8a-8cf753a40fc3)

	2. Теперь мы выбираем компоненты, которые хотим установить. То есть мы можем сделать свою сборку драйвера. Там есть описание к каждому компоненту. Я покажу свою сборку, которая подойдёт для игр и работы:
	   - Display Driver
	   - PhysX
	   - C++ 2017
	   - FreamView SDK (нужен только если вы будите заниматься продвинутым мониторингом ресурсов. Если вы не смотрите какое у тебя время кадра, его график, low 1%, low 0.1% FPS, и даже не знаешь что это, то тебе это **не нужно**)
	   - **NV Platform Controller** (Это только для ноубуков! Таких как Predator, читать описание!)
    
	     ![Pasted image 20231010234033](https://github.com/user-attachments/assets/da141067-4ce1-4307-8aa1-e24e60c418fd)

	3. Далее мы выбираем твики, которые нужно будет использовать:
		1. Удалить рекламу — ш-п-и-о-н-оооооо-в
		2. Делаем очистку после установки
		3. Включаем MSI Mod, об этом позже
		4. Включаем настройку для Easy Anti Cheat (без неё игры с этим античитом тебя не впустят)
		5. Можно включить Patch NVENC если занимаемся монтажом и рендром на GPU или/и с видео-ускорителем — **не обязательно, этот патч в обще ещё не проверен**
  
		   ![Pasted image 20231010234916](https://github.com/user-attachments/assets/1c6ebcfe-f298-49ab-b92a-907fc2c7f392)

		   ![Pasted image 20231010235205](https://github.com/user-attachments/assets/29250c3e-6c69-4e0f-a692-5e2f2ac46e3e)

		6. Клик "Next"
	4. Нажимаем "Install". Далее устанавливаем драйвер как обычно с выборочной установкой и чистой установкой — классика.
	5. Перезагружаемся

### Настройка Nvidia

Тут опять же всё на свой цвет и запах, или что у вас там. Я рекомендую следующие:
1. Изменить разрешение: Ставим Full цвет

![Pasted image 20231010235829](https://github.com/user-attachments/assets/75b4dfb8-61ea-4eb3-99f0-2521e543453c)

2. Цифровое аудио. Если у вас звук не выводиться через видеокарту также как у меня, то отключаем не нужные аудио устройства

![Pasted image 20231011000007](https://github.com/user-attachments/assets/7a433820-6bcb-40dd-aec7-03151ff37019)

3.  Ставим расширенные настройки 3D и настраиваем их

![Pasted image 20231011000102](https://github.com/user-attachments/assets/c2d4b7c5-8568-4b58-baf8-ac204165915a)

![Pasted image 20231011000229](https://github.com/user-attachments/assets/54663b59-f305-47ec-a1e8-fd322f782caf)

![Pasted image 20231011000319](https://github.com/user-attachments/assets/0f1aa2df-40b9-4712-ac56-f9f19c5dabd7)

![Pasted image 20231011000334](https://github.com/user-attachments/assets/d356c6bf-5e74-423f-8bc5-6ca1b1eb3b52)

4. Нажимаем "Применить" и заходим в последнею настройку в которой выбираем свою видеокарту:

![Pasted image 20231011000445](https://github.com/user-attachments/assets/30464235-0521-41a6-b709-8aed2bd3082d)

5. Готово

## Остальные драйвера

Тут всё весьма просто и одновременно сложно. Так как устанавливать их будем вручную. Если вы всё сделали, и даже установили драйвера от производителя (например у тебя ноут) — https://www.aida64.com/looking-driver-update, то тут впрочем делать не чего. А если ты без собственного софта для обновления драйверов, то добро пожаловать. У нас будет такой алгоритм:

1. Запускаем программу **SDI**
2. Выбираем "Загрузить только Индексы"

![Pasted image 20231021141420](https://github.com/user-attachments/assets/b4c8cd06-251c-40b8-b30c-34af0b4d225f)

3. Далее "Только для этого ПК" и "Ок". Ждём загрузки и продолжаем

![Pasted image 20231021141700](https://github.com/user-attachments/assets/587b7416-29ee-42f5-a01d-4e42d5366158)

4. Выбираем "Неустановленные" и "Новые версии" драйверов

![Pasted image 20231011000952](https://github.com/user-attachments/assets/9d024468-0222-4e23-8e83-fb8ee20e75dd)

5. Далее мониторим все драйвера, которые нужно установить или обновить. Тут у нас есть два варианта: 
1. Установить при помощи этого ПО. Для этог овыбираем что нам нужно обновитьЮ будьте внимательны.
2. Установить самому, что я рекомендую, но справедливости ради, оно хорошо определяет найденые драйвера, например мржет предупридить если он без подписи.
Воспользуемся вторым вариантом. Для этого наводим мышкой на драйвер и смотрим кто он, откуда он, что у нас за версия, какую он хочет. И ищем это добро в интернете.

![Pasted image 20231011001212](https://github.com/user-attachments/assets/51b7c5e2-7d6d-401e-9bc3-7fc34c977b07)

![Pasted image 20231011001442](https://github.com/user-attachments/assets/bd3ed9fe-4477-4755-a548-3fded0cfc71c)

Вот на примере контроллера. Мы видим что за устройство и можем его пробить в поиске. При поиске драйвера обращаем внимание на версию и дату нового драйвера, для справки можем воспользоваться названием драйвера.

В завершение после всех манипуляций, мы можем включить автообновление драйверов обратно. После этого незабываем проверить обновления Windows. Так как они лучше нашего ищут драйвера, хотя далеко не все.

## Прокачка Windows

Я не знал как назвать этот пункт, называть его по типу "настройка" или "отладка" хоть это более педантично, но тем не менее не корректно. Это последний этап продвинутой оптимизации основный на стороннем ПО. Тут мы завершим прекрасную настройку, которую я люблю, такую как очистка ОЗУ, динамический менеджмент ресурсов, переадресация ядер и другое.

### Дополнительные твики

Начнём с доп. твиков для системы:
1. **MenuShowTimeout.reg** — данный твик не сложный, он включает опцию авто завершение зависших программ (если она по какой-то причине выключена) и занижает задержки Пуска

![Pasted image 20231015142701](https://github.com/user-attachments/assets/87235dff-a42e-4020-8733-f33d7797c4cd)

2. **Large System Cache.reg** — спорный твик, но всё же. Там есть два параметра, попробую объяснить что они делают. _LargeSystemCache_ — ОС любит резервировать память для себя в ОЗУ, чтобы каждый раз не обращаться к HDD/SSD. Она это делает с учётом того, чтобы оставить немного сводного места доя резервирования, что логично, то есть она зарезервировала 20%, но использует из этих 20% только 5%, к примеру. Данный твик позволяет всегда использовать оптимальный объём резервирования памяти для своих данных и в теории: понизить не рентабельное использование ОЗУ. _DisablePagingExecutive_ — не менее интересный твик. Мы делали файл подкачки, так вот ядро ОС кэширует своё ядро в "page file" на диски (там где наш файл подкачки), данный твик "запрещает" это делать и "заставляет" кэшировать ядро в ОЗУ.

![Pasted image 20231015144710](https://github.com/user-attachments/assets/36efbd93-43ab-4f31-988d-e4ba2a547be0)

Как я ранее сказал это спорно. Ибо эффекта от этого может не послужить. Во-первых мы будем авто. очищать закэшированный пул ОЗУ. Во-вторых, если мы создали файл подкачки на SSD или NVME, то разницы может быть не много от ОЗУ. К тому же стоит учитывать используемый объём ОЗУ, ибо если её мало, то тогда такой твик может наоборот навредить, мало это: 1-2 Гб свободной ОЗУ от сильной нагрузки 

### Службы ОС

Службы, службы, службы... Ох... В общем, если вы не знаете какие службы как работают, то конечно лучше их в обще не трогать. Службы — это такая штука которая может работать непосредственно с ядром ОС, может работать с приложением ОС, а может быть в обще создана какой-то программой или пользователем. Тут начинается настоящая борьба пользователя с ОС. Службы — это круто! Они автоматизируют работу ПК, ими можно создать выполнение тех или иных команд автоматически, самый распространённый вариант это например автозапуск твоего Steam при включение ОС. Однако Службы — это процессы, а значит они обрабатываются процессором и могут работать в фоне нагружая его лишний раз. Часто бывает что отключение службы, особенно для слабого ПК даёт ему хороший boost производительности, а ещё часто бывает что ты делаешь свой ОС дауном, который не может выполнять какие-то операции потому что ты отключил службу, которая казалось бы не нужна.

![Pasted image 20231015150726](https://github.com/user-attachments/assets/b3225d01-7eb2-4f9e-a429-f8159c917a53)

Вся сложность заключается не только в том, что не всегда понятно за что отвечает служба, но ещё и наличие у служб иерархии, то есть отключение одной службы может привести к не работе других. **НЕНУЖНО** использовать программы для отключения служб, ибо никто другой не должен решать за тебя, какая служба должна быть выключена, а какая нет. Способов найти ту или иную службу и выключить её очень много, вот тут можно почитать про службы: [Начальная страница служб – Win 10 Tweaker – Оптимизация Windows, Службы Windows, Твики Windows](https://win10tweaker.ru/twikinarium/services) — Достаточно иронично получилось.

Мы отключим самые скорее всего не нужные службы. Если твоя Windows работает и так быстро, в меню автозагрузок у тебя не свалка, у тебя не пентиум 4 и >= 8 ГБ ОЗУ, то можешь в принципе пропустить данный этап. Хочу заметить, что бывают случае, когда вернуть корректную работу служб не получится, потому что ты сломал ОС, в том числе додумался всё же что-то вырезать из неё. Есть целое комьюнити лиги по борьбе со ордой служб ОС, давай вступим в их гильдию! Вперёд:

1. Делаем бэкап всех служб. После его активации у нас появится .reg файл, запустив который мы вернём стандартные параметры служб.
2. Не забываем сделать бэкап реестра.
3. Далее запускаем .reg файл: "**Рекомендованные службы.reg**" — тут лежит список служб, которые мы будем отключать. Остановимся на этом моменте подробнее:
	1. ALG — Служба шлюза уровня приложения. Обеспечивает поддержку стороннего протокола для общего доступа к подключению к Интернету. На данный момент это служба потерял свою актуальность ещё с Windows 7.
	2. AppMgmt — Управление приложениями. Служба, использующаяся на предприятиях с огромным количеством компьютеров, где необходима установка программ здесь и сейчас, сразу и всем
	3. AppReadiness — Готовность приложений. Служба необходима для того, чтобы замедлить загрузку Windows за счёт потраченного времени на подготовку к запуску плиточных приложений. Ускоряет запуск ОС при том не влияет на скорость запуска приложений
	4. BDESVC — Служба шифрования дисков BitLocker. Если коротко это служба и так работает говяно, если вы не шифруете диски при помощи средств Windows, то смысла от неё совсем нету, при том она может тормозить ОС
	5. CDPSvc — Служба платформы подключенных устройств. мы её не отключаем, это шпион, но он него зависит работа тех же виртуальных рабочих столов. Переводим в режим "Вручную"
	6. EFS — Шифрованная файловая система (EFS), также относится к BitLocker-у. Можно отключать если не пользуемся им.
	7. lfsvc — Служба географического положения. Служба, определяющая ваше местоположение по ГЛОНАСС, GPS и IP. Если мы не используем определение местоположения нашим устройством, то отключаем
	8. TrkWks — Клиент отслеживания изменившихся связей. - Функции службы прекрасно работают локально и по сети без включённого состояния
	9. WSearch — Windows Search. Windows Search постоянно индексирует содержимое дисков, чтобы, в случае вашего Поиска по системе, результаты поиска отображались быстрее. Ранее мы говорили о том, чтобы использовать другие инструменты для поиска
	10. BcastDVRUserService — Пользовательская служба DVR для игр и трансляции. Отключение службы никак не коснётся Bandicam, OBS и прочего ПО для стриминга и записи.
	11. AssignedAccessManagerSvc — Служба AssignedAccessManager. Отключение этой службы приведёт к тому, что при создании Киоска. Киоск нам не нужен
	12. MapsBroker — Диспетчер скачанных карт. Служба, необходимая для встроенного приложения Карты, чтобы отображать карты, которые скачивает пользователь.
	13. WpcMonSvc — Родительский контроль. Служба давно не работает
	14. wisvc — Служба предварительной оценки Windows. Предоставляет поддержку инфраструктуры для Программы предварительной оценки Windows. Чтобы Программа предварительной оценки Windows работала, эта служба должна быть включена.
	15. SensrSvc — Служба наблюдения за датчиками. Служба, отвечающая за яркость экрана благодаря показателям датчиков планшета / смартфона под управлением Windows
	16. SensorService — Служба датчиков. Служба, занимающаяся определением планшета в пространстве. Вы поворачиваете планшет под управлением Windows, а служба датчика следит за этим, и переворачивает картинку.
	17. SensorDataService — Служба данных датчиков. Служба, определяющая количество датчиков на планшете под управлением Windows.
	18. SEMgrSvc — Диспетчер платежей и NFC/защищенных элементов. Служба, поддерживающая использование NFC на вашем устройстве.
	19. SCPolicySvc — Политика удаления смарт-карт. Служба, позволяющая блокировать Рабочий стол при извлечении [смарт-карты](https://win10tweaker.ru/twikinarium/services/%d1%81%d0%bc%d0%b0%d1%80%d1%82-%d0%ba%d0%b0%d1%80%d1%82%d0%b0).
	20. ScDeviceEnum — Служба перечисления устройств чтения смарт-карт. Служба, необходимая плиточным приложениям из Магазина Windows, чтобы те могли получать доступ к [смарт-картам](https://win10tweaker.ru/twikinarium/services/%d1%81%d0%bc%d0%b0%d1%80%d1%82-%d0%ba%d0%b0%d1%80%d1%82%d0%b0), если это необходимо.
	21. SCardSvr — Смарт-карта. Основная служба, запускающая все процессы, связанные со смарт-картами.
	22. CertPropSvc — Распространение сертификата. Обязательная служба [смарт-карт](https://win10tweaker.ru/twikinarium/services/%d1%81%d0%bc%d0%b0%d1%80%d1%82-%d0%ba%d0%b0%d1%80%d1%82%d0%b0), позволяющая устанавливать драйверы для смарт-карт и хранить корневые сертификаты смарт-карт (основные принципы авторизации смарт-карт).
	23. RemoteRegistry — Удаленный реестр. Служба, позволяющая администрировать системный реестр с помощью удалённого доступа.
	24. EntAppSvc — Служба управления корпоративными приложениями. Служба, позволяющая удалённо выполнять развёртывание и удаление плиточных приложений в локальной сети. Используется на серверных корпоративных компьютерах.

Это далеко не весь список служб, которые можно отключить. Я составил щадящий список, который подойдёт абсолютно для любого пользователя, в независимости от того для чего будет использоваться ПК/Ноут. Для **ноутов планшетов не подходит**. _Для использования перетаскиваем .reg файл в "PowerRun"_

4. Отключаем автозагрузки: **Параметры > Приложения > Автозагрузка**. Либо используем приложение "**[Autoruns for Windows - Sysinternals | Microsoft Learn](https://learn.microsoft.com/en-us/sysinternals/downloads/autoruns)**"

![Pasted image 20231015171245](https://github.com/user-attachments/assets/03f01006-8e8e-4ced-9856-dd5e583e0b0c)

###  MSI Mode Tool

MSI Mode Tool — это инструмент, который позволяет пользователю оптимизировать работу процессора, управляя режимом работы интегрированного контроллера памяти (IMC). IMC — это элемент внутренней архитектуры процессора, отвечающий за обмен данными с оперативной памятью. Другими словами когда процессор отправляет запрос на чтение или запись данных в оперативную память, IMC преобразует эти запросы в соответствующие команды для памяти. Однако, для оптимальной производительности, необходимо, чтобы данные передавались и обрабатывались наиболее эффективным образом. Вот где Msi mode может пригодиться.

![Pasted image 20231015172157](https://github.com/user-attachments/assets/595b6be9-819e-4d64-843e-9bc5ace5c73f)

1. Запускаем программку от админа. В ней мы видим наименование драйвера и то в каком режиме он работает, в том числе какие режимы он поддерживает и какой у него приоритет ввода.
2. Тут всё просто: включаем mod MSI для каждого устройства который его поддерживает, также для USB и GPU можно выставить приоритет. Также можно выставить высокий приоритет для сетевой карты, PCI в котором находится GPU и SATA  — для этого мы можем видеть, что в параметрах устройства указные сведения о нём, мы можем включить диспетчер устройств и через него найти нужное нам устройство. После чего нажимаем "Apply"

![Pasted image 20231015172557](https://github.com/user-attachments/assets/924fa922-6185-4742-8a41-e1fc062a9327)

3. Не забываем презагружаться. 

### Переадресация ядер

Переадресация ядер или по другому прерывание. В общем все наши устройства, а именно аппаратно-программная составляющая взаимодействует с процессором, что не удивительно, так как им нужно выполнять инструкции. Как мы знаем из проекта [Tomnor] у нас есть конвейер ядра и многопоточность при которых те или иные сценарии выполняются несколькими ядрами процессора. Почему-то так устроено, что практически все наши устройства обрабатываются первым ядром или несколькими включая первое. И тут мы сталкиваемся с таким моментом, что в любом случае первое ядро самое быстрое и как правило оно нагружается при любом раскладе. Допустим у нас 8 ядер, мы играем в игру, где плохо реализовано многоядерная оптимизация, по итогу мы видим что первые два ядра нагружены, а остальные чилят. Как ты уже мог понять, то они же и обрабатывают устройства и могут вызывать задержки и проблемы, ибо ядру будет просто не хватать кэша и тактов для плавной и быстрой обработки инструкций устройства параллельно выполнением инструкций игры. Мы будем переадресовывать некоторые устройства на другие ядра, чтобы другие тяжёлые задачи не влияли на их работу.

В обще эта тема касается так называемых альфа ядер, и не совсем корректно говорить что corr0 — это самое быстрое ядро. Скажу так, с технической точки зрения никаких Альфа, Сигма ядер нет, конечно можно сказать что P и E ядра как-то относиться к этому, но это уже другая тема. Поэтому давайте Я, поставлю точку в этой теме.

**Переадресация ядер** (поиск "Альфа" ядер) — это процесс, при котором мы вручную назначаем некоторые процессы, в том числе драйвер на конкретное доступное ядро процессора. Данный процесс позволяет _примерно_ определить производительное ядро(-а) в конкретной среде.

![Pasted image 20231015174651](https://github.com/user-attachments/assets/135387c0-18a7-4442-a767-a42b577fc9f2)

1. Воспользуемся скриптом от AMIT создателя сборки Windows EVA. Запускаем скрипт "AutoGpuAffinity" от админа для переадресации ядра у GPU:

![image](https://github.com/user-attachments/assets/f02e26d4-7168-4d5c-ac90-40dfc8d3372b)

В общем, что мы тут видим. Это скрипт на фреймворки Lava. В файле config мы можем вносить изминения для тестирования:

![image](https://github.com/user-attachments/assets/910b91bc-9ba7-435d-b71e-95c6a73b0b8b)

1) Нас тут интересует выбор тестируемых ядер процессора. Можно установить свой массив, например как у меня
custom_cpus=[0,2,4,6,8,10,12,14,16,18,20,22]
Я рекомендую оставить пустой массив: custom_cpus=[]
2) Также мы можем поменять GPU движок: Vulkan/DirectX 9
3) Указать сколько будет по времени проходить один цикл в секундах. Чем дольше, тем лучше результат мы можем получить:
benchmark_duration=60

Остальные параметры вы можете менять по своему усмотрению, поиграться всегда можно. Скажем так, тестирование максимально приближено к какой-то вразумительной среде. Но я бы не стал на этом застрять внимание, так как это лишь в теории может дать положительный результат.

2. Если поменяли config, сохраняем его, а AutoGpuAffinity перезапускаем.
3. Запускаем тестирование, перед этим выключаем любые приложения и всё лишнее. И ждём результатов:

![image](https://github.com/user-attachments/assets/129f6ff3-2974-4796-b07d-2e1a1224f9df)

Тут мы получаем полный спектр результатов для каждого ядра. Лично я считаю, что можно ориентироваться по любому параметру. Но я как и автор рекомендуем смотреть на 1% Low показатели. Либо смотреть самые годные результаты в одной строке, например ядро 8. Тестирование нужно проводить несколько раз, записывая свои результаты. В теории результаты не должны сильно меняться, если это так, то нужно ковырять config. Но как я уже говорил, лучше не заострять на этом внимание

4. Запускаем ПО: GoInterruptPolicy от админа

![image](https://github.com/user-attachments/assets/329dcc5d-eca2-44c0-a32b-8aaa65bb0beb)

Тут нам нужно найти своё GPU, кстати тут тоже можно настроить MSI. Так вот. Кликаем по нему дважды и получаем такое окно:

![image](https://github.com/user-attachments/assets/765d4035-4faf-4217-b35d-17ffe6eeff96)

5. Тут в Device Policy мы выбираем параметр: IrqPolicySpecifiedProcessors.
6. И тут же выбираем наши ядра, хочу заметить, что никто не мешает выбрать несколько ядер. Однако хочу заметить что не нужно выбирать потоки: CPU 1, 3, 5, 7 и т.д. Чтобы узнать свои физические ядра, можно воспользоваться файлом "**Узнать физические ядра.bat**". И никто не мешает вам выбрать несколько ядре, к примеру 8, как в примере теста и 10. Но если у вас 4 ядерный процессор, лучше выбрать только одно ядро, так как в бедуем мы будем убирать с этого ядра другие процессы.
7. Сохраняемся и выполняем перезагрузку системы.
8. При помощи ПО от Melody можно проверить соответствие
9. Теперь при помощи ПО "**Interrupt Affinity Policy Tool**" или "**GoInterruptPolicy**" мы можем сделать переадресацию для других устройств, например USB, таким образом мы сможем избежать его некорректную работу при нагрузки CPU. Тут всё немного сложнее. Так как нам нужно будет воспользоваться диспетчер устройств, чтобы найти нужное устройство. Покажу на примере "**Interrupt Affinity Policy Tool**", я ьы рекомендовал использовать GoInterruptPolicy (https://github.com/spddl/GoInterruptPolicy), так как он свяжее, принцип такой же как мы делали с GPU:
	1. Переходим в диспетчер задач —> во вкладке "Вид" выбираем "Устройства по подключению"
	2. Нас интересует "PCI Express Root Comlex"
 
	   ![Pasted image 20231015192327](https://github.com/user-attachments/assets/d9dce644-9d01-42ad-864b-187ee11691a3)

	3. Тут находятся наши порты.  Как правило нас интересует хост-контроллер, но это может быть и другое устройство в зависимости от конфигурации ПК/ноут.
 
	   ![Pasted image 20231015192524](https://github.com/user-attachments/assets/397db25f-e66e-4206-b719-75fed3165feb)

	4. Тут мы находим свою мышку, я также нашёл клавиатуру. В обще брать устройство и отключать его в диспетчере, так можно понять то это устройство или нет. Но лучше отключать от самого ПК/ноута физически, а то потом например мышь будет проблематично включить обратно
	5. После того как мы узнали к какому хост-контроллеру подключены наши устройства, мы ищем их в ПО. Чтобы убедиться, мы можем взглянуть на размещение устройства и сверить его:
 
	   ![Pasted image 20231015193124](https://github.com/user-attachments/assets/73ce7fb9-2dc3-4a8a-888a-6cdbb7841658)

	6. Выбираем наше устройства в ПО и нажимаем "Set Mask"
	7. Тут выбираем наше физическое ядро, кроме ядра GPU в моём случае это 6, и ЦП1 — 0
 
	   ![Pasted image 20231015193402](https://github.com/user-attachments/assets/ace63b5a-1b80-47e0-b42f-e7275e0206fd)

	8. Нажимаем "ОК", нам предложат перезагрузиться, но мы отменяем предложение и сделаем это позже, к тому же по некоторым слухам могут возникнуть баги. Такой процесс можно сделать для всех нужных нам устройств: звук, сеть, клавиатура и другие.
10. Прежде чем продолжить запустим скрипт "**install startup.bat**" — он при включение ПК ставит низкий приоритет некоторым службам, таким как svchost.exe, dwm.exe и так далее

![Pasted image 20231015195557](https://github.com/user-attachments/assets/229c3cb7-3718-4eba-834b-04dccf1b4214)

_Делать это не обязательно_. Но нам это понадобиться для следующего пункта. Не забываем сделать **перезагрузку**.

11. В заключение мы можем убрать потоки с процессов, которые использует ОС. Для этого используем "**Убрать поток с процессов.bat**" от того же AMIT-а.
   
   Как это работает? Мы выбираем ядро (физическое или виртуальное), которое нужно убрать с процессов. В моём случае это 4 и 6 ядро, после выполнения скрипта, эти ядра не будет использовать ОС для своих процессов, которые весят у нас в диспетчере задач (из прошлого пункта)

![Pasted image 20231015204452](https://github.com/user-attachments/assets/e17f502e-15ca-451f-ae5c-bedf9edd65e4)

На этом с переадресацией ядер мы закончили. В качестве альтернативы и автоматизации мы можем использовать ПО [Process Lasso](https://bitsum.com/)

### Дополнительная функция масштабирования

Этот пункт нужен только для тех, кто не играет в игры на своём родном разрешение. Например я. Если у вас FullHD и вы например играете в какие-то игры с другим разрешением в масштабе 16:9, то наверняка у вас были проблемы с чёрными полосками и масштабированием, вот этот пункт посещён этому моменту, если у тебя такого нет, то смело пропускай его.

Для этого мы будем использовать ПО "**Custom Resolution Utility**":

1. Выбираем наш монитор

![Pasted image 20231016201910](https://github.com/user-attachments/assets/428b559e-3d7a-48c8-b937-062142b76b93)

2. После чего нажимаем "Add..."
3. Далее выбираем тайминг "Automatic (PC)" —> разрешение на котором мы играем —> герцовку нашего монитора

![Pasted image 20231016202143](https://github.com/user-attachments/assets/4be86fdf-82a2-4fc2-9ad3-ea1a0ffef233)

4. Нажимаем "ОК"
5. Теперь важный момент. Для чего это делается. Мы создали сейчас новые настройки Resolution. Это означает, что _все_ приложения и игры будут думать, что это наше основное разрешение и настройки монитора и выставлять их по дефолту. Чтобы сделать это, нужно перенести наше новое разрешение стрелкой вверх на первое место:

![Pasted image 20231016202449](https://github.com/user-attachments/assets/bc11ce73-69e8-42cc-a025-7ab6c5106754)

Таким образом, если мы хотим играть и пользоваться своим основным разрешением, то в играх его придётся менять на классическое (родное), либо постоянно менять настройки этого ПО

6. Далее запускаем .exe "**перезагрузить драйвера ГП**", чтобы GPU схавал нашу фейковую инфу о родном разрешение.
7. Далее отключаем в драйвере GPU масштабирование ГП и выставляем масштабирование черед дисплей

### Интеллектуальный очиститель списка ожидания

[ISLC](https://www.wagnardsoft.com/forums/viewforum.php?f=18&sid=bac69e9814cd22251fb59a94123c9ad5 "Intelligent standby list cleaner (ISLC)") — это замечательный скрипт. Опишу принцип его работы: он работает в фоне, как мы ранее говорили система резервирует память ОЗУ, но она это делает не только для себя, но ещё и для всех процессов, которые выполняются на ПК/ноут. Однако Microsoft не удосужилась сделать так, чтобы зарезервированная память очищалась, по итогу она по немного жрёт наше ОЗУ и не возвращает его обратно, засоряя список ожидания дальше:

![Pasted image 20231016205705](https://github.com/user-attachments/assets/2f210ed3-64ec-4b28-aa41-cc0925a2130e)

Как уже понятно ISLC очищает нам этот список ожидания.

1. Запускаем "**ISLC v1.0.2.9.exe**"
2. Выбираем путь распаковки скрипта, крайне рекомендую распаковать в укромное место диска C:/
3. Переходим в директорию распаковки
4. И запускаем "**Intelligent standby list cleaner ISLC.exe**"

![Pasted image 20231016210155](https://github.com/user-attachments/assets/c800ed49-4f0a-4f7f-809f-cbb85cf7ea77)

5. Теперь её необходимо настроить:
	1. Для начала настроим условия при которых программа очистит лист ожидания
		1. _The list size is at least:_ тут мы устанавливаем максимальный пороговый размер зарезервированной памяти в Mb. То есть, если мы установим 1024 Mb, то список не будет очищаться при условие что лист ожидания заполнен на x < 1024 Mb
		2. Free memory is lower than: тут указываем максимальный объём свободной физической памяти, то есть если у нас осталось свободной памяти < 1024 Mb, то это условие будет выполнено
		3. Вспоминаем алгебра-логику и логический элемент И, очистка списка будет происходить только при выполнение двух условий. По дефолту: первое условие **1024**, второе условие **2048** — если зарезервированной памяти больше 1GB и свободной памяти осталось меньше 2GB, то зарезервированная память очиститься
	2. Ставим две галки для автоматического запуска скрипта при включение ПК
	3. Далее мы можем настроить задержку работы программы, то есть частота опроса в ms при котором она будет проверять что у нас с ОЗУ, я рекомендую оставить 1000 ms
6. Нажимаем кнопку "Start"

### WPS — интеллектуальный менеджер ресурсов (процессов)

Поздравляю. Если ты читаешь это, то спасибо что воспользовался данным проектом. Это последний этап, который нас предстоит выполнить. На этом моменте я выдаю тебе звание: Знаток оптимизации Windows. Поздравляю товарищ!

Программой WPS я пользуюсь с самого её выхода. На самом деле когда я впервые увидел данное ПО я посчитал его настоящей находкой, в этом я убеждён и по сей день. За время её использования она создала уже более 500 000 нейронных узлов основываясь на работе моего ПК.

Сейчас объясню что она делает. WPS — интеллектуальный менеджер ресурсов, который мониторит все запущенные процессы на ПК, он отслеживает их работу и в зависимости от этого выставляет тот или иной приоритет. Таким должен быть диспетчер задач, он должен выполнять эту функцию, но увы. При том данный алгоритм обучается, он имеет статистику использования того или иного процесса и относительно этого также выставляет приоритет. Также он может определить какое ПО или приложение запущенно в данный момент и активно используется, чтобы выдать ему максимальный приоритет для ОС.

Другими словами оно занимается менеджментом запущенных процессов во время использования ПК.

1. Запускаем "**WPS_Setup.exe**" и устанавливаем ПО
2. Мы можем настроить программу и посмотреть список процессов и их приоритет в данный момент. Но настройка доступна только на лицензированном ПО, к счастью они нам не обязательны, но с помощью их мы можем сами выставить нужные нам настройки, я покажу. Но совсем скоро ПО станет абсолютно бесплатным

![Pasted image 20231016213146](https://github.com/user-attachments/assets/7503643a-bdb7-4cf8-9af3-46cc876f05f1)

3. В настройка рекомендую отключить контроль питания, так как настройки электропитания мы уже сделали. Когда я общался с разработчиками, то они рассказали, что этот параметр автоматически на лету меняет настройки электропитания исходя из условий эксплуатации. В принципе мы можем оставить только параметры: Контроль нейросетью, режим обучения (отключить, если настраивать вручную), приоритеты ЦП и контроль HDD/SSD, остальное мы уже настроили вручную

![Pasted image 20231016214610](https://github.com/user-attachments/assets/be2dbd47-7b42-47f3-836d-d826b626dc02)

4. Далее идут правила которые мы можем вставить. При обучение программа сама определяет тот или иной процесс в группу, мы можем настроить то, какой приоритет она будет выставлять для каждой такой группы

![Pasted image 20231016214756](https://github.com/user-attachments/assets/dc29510e-2cd1-4aff-8daa-5ae136a62c35)

5. Дальше есть список ПО и их пресет настройки приоритета. Честно говоря список бесполезный, однако мы можем добавить какое-то своё ПО в данный список через запись в .ini файле

![Pasted image 20231016214956](https://github.com/user-attachments/assets/ef0d0242-0b57-48be-994f-fda360c0f013)

6. Если нажать по иконки в центре, то там мы увидим как программа мониторит использование ПО, а также какая программа в фокусе

![Pasted image 20231016215220](https://github.com/user-attachments/assets/82e0abb6-19ce-46b9-92a9-116cd9bd5ec7)

   По моему опыту она очень хорошо определяет приоритет ПО
   
7. После запуска ПО нужно вернуться в настройки электропитания и выставить обратно нашу настроенную схему электропитания

Более подробное описание функций и настроек ПО можно узнать [тут](https://winperst.ru/wps_details)
Может показаться что это похоже на рекламу, но к сожалению нет, просто тот кто шарит обо мне понимает почему она мне так нравится

---

## Заключение

Для начала я хочу показать, что мы достигли своих целей. **Вот до нашей оптимизации**:

![Screenshot_2](https://github.com/user-attachments/assets/03342a96-7f71-4924-bec8-faa1344eccbc)

![Screenshot_3](https://github.com/user-attachments/assets/e2c599c2-147d-438e-9092-b637839e9410)

**А это после неё**:

![Screenshot_3new](https://github.com/user-attachments/assets/183cec5a-57c7-436d-a7b4-2b27f5e61178)

![Screenshot_4new](https://github.com/user-attachments/assets/6fe5f1c2-5e0e-41c5-967e-05afe9c5d148)

Как мы можем заметить отзывчивость нашей системы в целом, то есть её задержки понизились в среднем на **13-16%**. А задержки некоторых устройств и драйверов понизились до **103%**, это прекрасный результат с учётом того, что в ходе данной оптимизации я никак не работал с обновлением и установкой драйверов, а оставил те что установила сама ОС

На этом наша продвинутая оптимизация Windows 11/10 подошла к концу. За этим стоит большой опыт и много практики в этом направление. Я конечно не являюсь лучшем или что-то в этом духе, как и все сборщики. Однако я дал пару "эксклюзивных" советов при написание проекта, так как многие либо делают как все, либо стараются сделать "нормально". Я же извращался над ОС как мог и часто ломал её, потом чинил и так узнавал о ней больше и о том, что написано в данном проекте. Многие материалы для удобства были взяты с проверенных людей: [ios1ph](https://www.youtube.com/@iosiph), [Ghost Spectre](https://www.youtube.com/@GHOSTSPECTRE/videos), [FadeMind](https://github.com/FadeMind?ysclid=lnulhjiuw1152570210) и [AMIT](https://github.com/amitxv). Моё и их творчество вы сможете увидеть в коде

Я старался сделать настройки оптимальными для любого пользователя, однако не могу гарантировать то, что в ваших условиях всё будет работать так как задумано. Ещё раз спасибо, что доверяете своё железо мне, с уважением и любовью ❤️‍🔥

	< MrWindows >
